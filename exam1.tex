
\documentclass[12pt]{article}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{multicol}
\usepackage{babel}
\usepackage{graphicx}
%%%\usepackage{tgschola}
%%%\usepackage{mathptmx}


\usepackage[margin=1in]{geometry}
\begin{document}
\title{CSC-458 Exam \#1}
\author{Gabriel Hofer}
\date{\today}
\maketitle
%------------------------------------------------------------------------------
\noindent \subsubsection*{Submission Contents} 
\noindent The compressed folder contains three items: {\ttfamily Makefile}, {\ttfamily dash.c}, {\ttfamily exam1.pdf}. \\ \\ {\ttfamily dash.c} contains the entire diagnostic shell program. {\ttfamily exam1.pdf} contains the writeup and documentation for the program. {\ttfamily Makefile} compiles {\ttfamily dash.c}. 

\noindent \subsubsection*{How to Run the Program} \par
Execute the following commands in the terminal to run the program: 
\begin{verbatim}
$ tar -xzf exam1.tgz
$ cd exam1
$ make 
$ ./dash
\end{verbatim}

\noindent \subsubsection*{Testing \& Verification} \par
This program was tested by running the {\ttfamily dash} executable and entering miscellaneous commands. Then, the output from {\ttfamily dash} was compared to the data or contents in the {\ttfamily /proc} directory to verify correctness.

\noindent \subsubsection*{main \& REPL} \par
The entry point for the program is the {\ttfamily main} function. {\ttfamily main} immediately calls the REPL (read-eval-print-loop). The REPL reads one line at a time and evaluates the command. If the command name is in the set \{ {\ttfamily cmdnm}, {\ttfamily pid}, {\ttfamily cd}, {\ttfamily systat} \}, then dash calls the function with the same name in the dash.c file. If the command isn't in the set, then {\ttfamily fork} and {\ttfamily execvp} are used to execute the command with a child process. The shell is terminated when the {\ttfamily exit} command is entered.

\newpage
\begin{verbatim}
void REPL(){
  char * buf=NULL;
  size_t leng=32;
  char a[32], b[32];
  char str[] = "cmdnm\0pid\0cd\0systat\0exit\0";
  char cwd[PATH_MAX];

  for(;;){
    a[0]=b[0]='\0';
    getcwd(cwd, sizeof(cwd));  
    printf("%s> ", cwd);
    getline(&buf, &leng, stdin);
    sscanf(buf, "%s%s", a, b);
    char allspaces=1;
    for(int i=0;i<strlen(buf);i++)
      allspaces = (allspaces && isspace(buf[i]));
    if(allspaces) continue;
    if(!strcmp(a, str)) cmdnm(b);	
    else if(!strcmp(a, &str[6])) pid(b);
    else if(!strcmp(a, &str[10])) cd(b);
    else if(!strcmp(a, &str[13])) systat();
    else if(!strcmp(a, &str[20])) return;
    else otherwise(buf); 
  }
}

void main(){ 
  REPL(); 
}
\end{verbatim}

\noindent \subsubsection*{cmdnm} \par
Returns the command string (name) that started the process for a given process id. The function looks in the {\ttfamily /proc/<PID>/stat } file for the command string (it's the second element in the file). 
\begin{verbatim}
void cmdnm(char * pid){
  char path[256], scratch[256], nm[256];
  sprintf(path, "/proc/%s/stat", pid);
  FILE * fp = fopen(path, "r");	
  if(fp==NULL) return;
  fscanf(fp, "%s%s", scratch, nm);
  printf("%s\n", nm);
  fclose(fp);
}
\end{verbatim}

\newpage
\noindent \subsubsection*{pid} \par
Returns the process IDs for a given command string. The function looks through every {\ttfamily /proc/<PID>/stat} file in the {\ttfamily /proc} directory and prints the name of a directory when the {\ttfamily command} function parameter matches the second element in a {\ttfamily stat} file.
\begin{verbatim}
void pid(char * command) {
  char pid[33], command2[256];
  sprintf(command2, "(%s)", command);
  DIR * dir;
  struct dirent *dp;
  if((dir = opendir("/proc")) == NULL){
    perror("Can't open directory\n");
    return;
  }
  while((dp = readdir(dir)) != NULL){
    char path[512], scratch[256], nm[256];
    sprintf(path, "/proc/%s/stat", dp->d_name);
    FILE *fp = fopen(path, "r");	
    if(fp==NULL) continue;
    fscanf(fp, "%s%s", scratch, nm);
    if(!strcmp(command2,nm))
      printf("%s\n",dp->d_name);
    fclose(fp);
  }
}
\end{verbatim}

\noindent \subsubsection*{systat} \par
Prints some process information to stdout: Linux version, 
system uptime, memory usage, cpu info. Specifically, the {\ttfamily showfile} function is called 4 times from {\ttfamily systat} to print the contents of 4 differents files. 
\begin{verbatim}
void showfile(char * filename){
  printf("%s: \n",filename);
  char * buf=NULL;
  size_t leng=32;
  char path[256];
  sprintf(path, "/proc/%s", filename);
  FILE * fp = fopen(path,"r");
  if(fp==NULL) return;
  while(getline(&buf, &leng, fp) != -1)
    printf("%s",buf);
  printf("\n");
  fclose(fp);
}
\end{verbatim}
\newpage
\begin{verbatim}
void systat(){
  char nm[] = "version\0uptime\0meminfo\0cpuinfo\0";
  showfile(nm);
  showfile(&nm[8]);
  showfile(&nm[15]);
  showfile(&nm[23]);
}
\end{verbatim}

\noindent \subsubsection*{cd} \par
Changes the directory according to the path given using the chdir() function.
\begin{verbatim}
void cd(char * dir){
  if(strlen(dir)==0)
    chdir(getenv("HOME"));
  else if(chdir(dir)!=0) 
    perror("something went wrong\n");
}
\end{verbatim}

\noindent \subsubsection*{fork \& execvp} \par
Creates a new child process. The child process executes the command that 
was entered in into {\ttfamily dash} from {\ttfamily stdin}. The parent process waits for the child process to terminate before proceeding. The PID of the child process is printed immediately after it's created. 
\begin{verbatim}
void otherwise(char * buf){
  int status;
  int pid = fork();
  if(pid!=0) printf("Child PID: %d\n",pid);
  if(pid==0){
    char * name[4];
    name[0] = "/bin/bash";
    name[1] = "-c";
    name[2] = buf;
    name[3] = NULL;
    execvp("/bin/sh",name);
  }
  get_RUSAGE_CHILDREN();
  waitpid(pid,&status,0);
}
\end{verbatim}
\newpage

\end{document}


